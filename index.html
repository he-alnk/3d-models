<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLB Viewer - Standard Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #1a1a1a;
            color: #fff;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            width: 320px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        #controls::-webkit-scrollbar {
            width: 8px;
        }

        #controls::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        #controls::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        #controls::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        h2 {
            margin: 0 0 15px 0;
            font-size: 20px;
            font-weight: 600;
            color: #4fc3f7;
            border-bottom: 2px solid #4fc3f7;
            padding-bottom: 8px;
        }

        h3 {
            margin: 20px 0 10px 0;
            font-size: 15px;
            font-weight: 600;
            color: #81c784;
            border-bottom: 1px solid rgba(129, 199, 132, 0.3);
            padding-bottom: 5px;
        }

        .section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section:last-child {
            border-bottom: none;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
            width: 100%;
            margin: 5px 0;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 2px 8px rgba(240, 147, 251, 0.3);
        }

        button.secondary:hover {
            box-shadow: 0 4px 12px rgba(240, 147, 251, 0.5);
        }

        .button-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin: 10px 0;
        }

        .button-grid button {
            margin: 0;
            font-size: 12px;
            padding: 8px 12px;
        }

        input[type="file"] {
            width: 100%;
            padding: 8px;
            margin: 8px 0;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 12px;
            cursor: pointer;
        }

        input[type="file"]::file-selector-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            font-size: 12px;
        }

        input[type="file"]::file-selector-button:hover {
            opacity: 0.9;
        }

        input[type="range"] {
            width: 100%;
            margin: 8px 0;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
        }

        input[type="range"]::-webkit-slider-track {
            background: rgba(255, 255, 255, 0.2);
            height: 6px;
            border-radius: 3px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            margin-top: -5px;
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.5);
        }

        input[type="range"]::-moz-range-track {
            background: rgba(255, 255, 255, 0.2);
            height: 6px;
            border-radius: 3px;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.5);
        }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin: 8px 0;
        }

        label {
            display: flex;
            align-items: center;
            margin: 10px 0;
            font-size: 13px;
            cursor: pointer;
            user-select: none;
        }

        input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #667eea;
        }

        .info-text {
            font-size: 12px;
            color: #aaa;
            margin: 5px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            border-left: 3px solid #4fc3f7;
        }

        .info-text.success {
            border-left-color: #81c784;
            color: #81c784;
        }

        .info-text.error {
            border-left-color: #e57373;
            color: #e57373;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            margin-bottom: 4px;
        }

        .slider-value {
            color: #4fc3f7;
            font-weight: 600;
            min-width: 40px;
            text-align: right;
        }

        #morphTargets {
            max-height: 300px;
            overflow-y: auto;
        }

        #morphTargets::-webkit-scrollbar {
            width: 6px;
        }

        #morphTargets::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        #morphTargets::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .morph-item {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .morph-name {
            font-size: 11px;
            color: #bbb;
            margin-bottom: 5px;
            font-weight: 500;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px 50px;
            border-radius: 12px;
            z-index: 1000;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        #loading.hidden {
            display: none;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #4fc3f7;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 10px 0;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-value {
            font-size: 18px;
            font-weight: 700;
            color: #4fc3f7;
            display: block;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
        }

        /* ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ä¸€è¦§ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        input[type="text"] {
            width: 100%;
            padding: 8px;
            margin: 8px 0;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 12px;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255, 255, 255, 0.15);
        }

        input[type="text"]::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .blendshape-list {
            max-height: 400px;
            overflow-y: auto;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 6px;
            padding: 10px;
        }

        .blendshape-list::-webkit-scrollbar {
            width: 6px;
        }

        .blendshape-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        .blendshape-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .mesh-group {
            margin-bottom: 15px;
        }

        .mesh-header {
            font-size: 13px;
            font-weight: 600;
            color: #ffa726;
            margin-bottom: 8px;
            padding: 8px;
            background: rgba(255, 167, 38, 0.1);
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .mesh-header:hover {
            background: rgba(255, 167, 38, 0.15);
        }

        .mesh-header .toggle-icon {
            font-size: 10px;
            transition: transform 0.3s;
        }

        .mesh-header.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }

        .blendshape-item {
            font-size: 11px;
            padding: 6px 10px;
            margin: 4px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-left: 2px solid transparent;
        }

        .blendshape-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .blendshape-item.lip-sync {
            border-left-color: #4fc3f7;
            background: rgba(79, 195, 247, 0.1);
        }

        .blendshape-item.highlight {
            background: rgba(255, 235, 59, 0.2);
            border-left-color: #ffeb3b;
        }

        .blendshape-name {
            flex: 1;
            color: #ddd;
        }

        .blendshape-index {
            font-size: 10px;
            color: #888;
            margin-right: 8px;
            min-width: 30px;
        }

        .badge {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            background: rgba(79, 195, 247, 0.3);
            color: #4fc3f7;
            margin-left: 8px;
            white-space: nowrap;
        }

        .badge.lip-sync {
            background: rgba(79, 195, 247, 0.3);
            color: #4fc3f7;
        }

        .export-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin: 10px 0;
        }

        .export-buttons button {
            font-size: 11px;
            padding: 6px 8px;
        }

        .no-results {
            text-align: center;
            padding: 20px;
            color: #888;
            font-size: 12px;
        }

        /* Visemeãƒ†ã‚¹ãƒˆã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .viseme-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin: 15px 0;
        }

        .viseme-btn {
            background: linear-gradient(135deg, #4fc3f7 0%, #29b6f6 100%);
            color: white;
            border: none;
            padding: 12px 8px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(79, 195, 247, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            min-height: 60px;
        }

        .viseme-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 195, 247, 0.5);
            background: linear-gradient(135deg, #29b6f6 0%, #039be5 100%);
        }

        .viseme-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(79, 195, 247, 0.4);
        }

        .viseme-btn .viseme-name {
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        .viseme-btn .viseme-phoneme {
            font-size: 10px;
            opacity: 0.9;
            font-weight: 400;
        }

        .viseme-btn.active {
            background: linear-gradient(135deg, #66bb6a 0%, #43a047 100%);
            box-shadow: 0 4px 12px rgba(102, 187, 106, 0.6);
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div id="loadingText">ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
    </div>

    <div id="controls">
        <h2>ğŸ“¦ GLB Viewer</h2>

        <!-- ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ -->
        <div class="section">
            <h3>ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿</h3>
            <input type="text" id="urlInput" placeholder="GLBãƒ•ã‚¡ã‚¤ãƒ«ã®URLã‚’å…¥åŠ›..." />
            <button onclick="loadFromURL()">URLã‹ã‚‰èª­ã¿è¾¼ã¿</button>
            <input type="file" id="fileInput" accept=".glb,.gltf" />
            <div id="fileInfo" class="info-text">URLã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„</div>
        </div>

        <!-- ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
        <div class="section">
            <h3>ğŸ“· ã‚«ãƒ¡ãƒ©ãƒ—ãƒªã‚»ãƒƒãƒˆ</h3>
            <div class="button-grid">
                <button onclick="setCameraPreset('front')">æ­£é¢</button>
                <button onclick="setCameraPreset('back')">èƒŒé¢</button>
                <button onclick="setCameraPreset('left')">å·¦å´é¢</button>
                <button onclick="setCameraPreset('right')">å³å´é¢</button>
                <button onclick="setCameraPreset('top')">ä¸Šã‹ã‚‰</button>
                <button onclick="setCameraPreset('reset')">ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
        </div>

        <!-- è¡¨ç¤ºè¨­å®š -->
        <div class="section">
            <h3>ğŸ¨ è¡¨ç¤ºè¨­å®š</h3>

            <label>
                <input type="checkbox" id="gridToggle" checked>
                ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º
            </label>

            <label>
                <input type="checkbox" id="autoRotate">
                è‡ªå‹•å›è»¢
            </label>

            <div style="margin-top: 15px;">
                <div class="slider-label">
                    <span>èƒŒæ™¯è‰²</span>
                </div>
                <input type="color" id="bgColorPicker" value="#333333">
            </div>

            <div style="margin-top: 15px;">
                <div class="slider-label">
                    <span>å¤ªé™½å…‰ã®å¼·åº¦</span>
                    <span class="slider-value" id="directionalLightValue">1.0</span>
                </div>
                <input type="range" id="directionalLightSlider" min="0" max="3" step="0.1" value="1.0">
            </div>

            <div style="margin-top: 15px;">
                <div class="slider-label">
                    <span>ç’°å¢ƒå…‰ã®å¼·åº¦</span>
                    <span class="slider-value" id="ambientLightValue">0.5</span>
                </div>
                <input type="range" id="ambientLightSlider" min="0" max="2" step="0.1" value="0.5">
            </div>
        </div>

        <!-- ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ— -->
        <div class="section" id="morphSection" style="display: none;">
            <h3>ğŸ˜Š ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—</h3>
            <button class="secondary" onclick="resetMorphTargets()">ã™ã¹ã¦ãƒªã‚»ãƒƒãƒˆ</button>
            <div id="morphTargets"></div>
        </div>

        <!-- ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ä¸€è¦§ -->
        <div class="section" id="blendshapeListSection" style="display: none;">
            <h3>ğŸ“‹ ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ä¸€è¦§</h3>

            <!-- æ¤œç´¢ã¨ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ -->
            <input type="text" id="blendshapeSearch" placeholder="ğŸ” ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—åã§æ¤œç´¢...">

            <label>
                <input type="checkbox" id="lipSyncFilter">
                ãƒªãƒƒãƒ—ã‚·ãƒ³ã‚¯ç”¨ã®ã¿è¡¨ç¤º
            </label>

            <!-- ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³ -->
            <div class="export-buttons">
                <button onclick="exportBlendShapesJSON()">ğŸ“„ JSON</button>
                <button onclick="exportBlendShapesText()">ğŸ“ ãƒ†ã‚­ã‚¹ãƒˆ</button>
                <button onclick="copyBlendShapesToClipboard()">ğŸ“‹ ã‚³ãƒ”ãƒ¼</button>
            </div>

            <!-- ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ä¸€è¦§ -->
            <div id="blendshapeListContainer" class="blendshape-list"></div>
        </div>

        <!-- Visemeãƒ†ã‚¹ãƒˆ -->
        <div class="section" id="visemeTestSection" style="display: none;">
            <h3>ğŸ¤ Visemeãƒ†ã‚¹ãƒˆ</h3>
            <div class="info-text">
                ä»•æ§˜æ›¸ã®ã€Œç‹¬è‡ªVisemeâ†’CC4ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—å¯¾å¿œè¡¨ã€ã«åŸºã¥ã„ã¦å£ã®å‹•ãã‚’ãƒ†ã‚¹ãƒˆã§ãã¾ã™ã€‚
            </div>

            <!-- Visemeãƒœã‚¿ãƒ³ -->
            <div class="viseme-grid">
                <button class="viseme-btn" onclick="applyViseme('silence')" title="ç„¡éŸ³">
                    <span class="viseme-name">silence</span>
                    <span class="viseme-phoneme">ç„¡éŸ³</span>
                </button>
                <button class="viseme-btn" onclick="applyViseme('a')" title="ã‚ã€ã‹ã€ã•">
                    <span class="viseme-name">a</span>
                    <span class="viseme-phoneme">ã‚ã€ã‹ã€ã•</span>
                </button>
                <button class="viseme-btn" onclick="applyViseme('i')" title="ã„ã€ãã€ã—">
                    <span class="viseme-name">i</span>
                    <span class="viseme-phoneme">ã„ã€ãã€ã—</span>
                </button>
                <button class="viseme-btn" onclick="applyViseme('u')" title="ã†ã€ãã€ã™">
                    <span class="viseme-name">u</span>
                    <span class="viseme-phoneme">ã†ã€ãã€ã™</span>
                </button>
                <button class="viseme-btn" onclick="applyViseme('e')" title="ãˆã€ã‘ã€ã›">
                    <span class="viseme-name">e</span>
                    <span class="viseme-phoneme">ãˆã€ã‘ã€ã›</span>
                </button>
                <button class="viseme-btn" onclick="applyViseme('o')" title="ãŠã€ã“ã€ã">
                    <span class="viseme-name">o</span>
                    <span class="viseme-phoneme">ãŠã€ã“ã€ã</span>
                </button>
                <button class="viseme-btn" onclick="applyViseme('n')" title="ã‚“">
                    <span class="viseme-name">n</span>
                    <span class="viseme-phoneme">ã‚“</span>
                </button>
                <button class="viseme-btn" onclick="applyViseme('k')" title="ã‹ã€ãã€ã">
                    <span class="viseme-name">k</span>
                    <span class="viseme-phoneme">ã‹ã€ãã€ã</span>
                </button>
                <button class="viseme-btn" onclick="applyViseme('s')" title="ã•ã€ã—ã€ã™">
                    <span class="viseme-name">s</span>
                    <span class="viseme-phoneme">ã•ã€ã—ã€ã™</span>
                </button>
                <button class="viseme-btn" onclick="applyViseme('t')" title="ãŸã€ã¡ã€ã¤">
                    <span class="viseme-name">t</span>
                    <span class="viseme-phoneme">ãŸã€ã¡ã€ã¤</span>
                </button>
                <button class="viseme-btn" onclick="applyViseme('h')" title="ã¯ã€ã²ã€ãµ">
                    <span class="viseme-name">h</span>
                    <span class="viseme-phoneme">ã¯ã€ã²ã€ãµ</span>
                </button>
                <button class="viseme-btn" onclick="applyViseme('m')" title="ã¾ã€ã¿ã€ã‚€">
                    <span class="viseme-name">m</span>
                    <span class="viseme-phoneme">ã¾ã€ã¿ã€ã‚€</span>
                </button>
                <button class="viseme-btn" onclick="applyViseme('y')" title="ã‚„ã€ã‚†ã€ã‚ˆ">
                    <span class="viseme-name">y</span>
                    <span class="viseme-phoneme">ã‚„ã€ã‚†ã€ã‚ˆ</span>
                </button>
                <button class="viseme-btn" onclick="applyViseme('r')" title="ã‚‰ã€ã‚Šã€ã‚‹">
                    <span class="viseme-name">r</span>
                    <span class="viseme-phoneme">ã‚‰ã€ã‚Šã€ã‚‹</span>
                </button>
                <button class="viseme-btn" onclick="applyViseme('w')" title="ã‚">
                    <span class="viseme-name">w</span>
                    <span class="viseme-phoneme">ã‚</span>
                </button>
            </div>

            <button class="secondary" onclick="resetViseme()" style="margin-top: 10px;">ã™ã¹ã¦ãƒªã‚»ãƒƒãƒˆ</button>
        </div>

        <!-- ãƒ¢ãƒ‡ãƒ«æƒ…å ± -->
        <div class="section">
            <h3>â„¹ï¸ ãƒ¢ãƒ‡ãƒ«æƒ…å ±</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <span class="stat-value" id="verticesCount">-</span>
                    <span class="stat-label">é ‚ç‚¹æ•°</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="facesCount">-</span>
                    <span class="stat-label">é¢æ•°</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="meshesCount">-</span>
                    <span class="stat-label">ãƒ¡ãƒƒã‚·ãƒ¥æ•°</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="materialsCount">-</span>
                    <span class="stat-label">ãƒãƒ†ãƒªã‚¢ãƒ«æ•°</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="texturesCount">-</span>
                    <span class="stat-label">ãƒ†ã‚¯ã‚¹ãƒãƒ£æ•°</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="morphTargetsCount">-</span>
                    <span class="stat-label">ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—</span>
                </div>
            </div>
        </div>

        <!-- ãã®ä»– -->
        <div class="section">
            <h3>ğŸ”§ ãã®ä»–</h3>
            <button class="secondary" onclick="takeScreenshot()">ğŸ“¸ ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ</button>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <!-- Three.js -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // ========== ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®è¨­å®š ==========
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);

        const camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 1.5, 3);

        const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true,
            preserveDrawingBuffer: true // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆç”¨
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // ========== ãƒ©ã‚¤ãƒˆ ==========
        const directionalLight = new THREE.DirectionalLight(0xffffff, Math.PI);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        const ambientLight = new THREE.AmbientLight(0xffffff, Math.PI * 0.5);
        scene.add(ambientLight);

        // ========== ã‚°ãƒªãƒƒãƒ‰ ==========
        const gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0x444444);
        scene.add(gridHelper);

        // ========== OrbitControls ==========
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1, 0);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 0.5;
        controls.maxDistance = 50;
        controls.update();

        // ========== ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ==========
        let currentModel = null;
        let currentGltf = null;
        let modelBoundingBox = null;
        let modelCenter = new THREE.Vector3();
        let modelSize = new THREE.Vector3();
        let defaultCameraPosition = new THREE.Vector3(0, 1.5, 3);
        let defaultCameraTarget = new THREE.Vector3(0, 1, 0);
        let autoRotateEnabled = false;
        let morphTargetMeshes = [];
        let blendShapeData = []; // ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ä¸€è¦§ãƒ‡ãƒ¼ã‚¿

        // ãƒªãƒƒãƒ—ã‚·ãƒ³ã‚¯ç”¨ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—åï¼ˆä»•æ§˜æ›¸ + Character Creatorå°‚ç”¨Visemeï¼‰
        const lipSyncBlendShapes = [
            // æ¨™æº–ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—
            'JawOpen', 'MouthClose', 'MouthSmile', 'MouthFunnel',
            'MouthPucker', 'MouthFrown', 'TongueOut',
            // å°æ–‡å­—ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³
            'jawOpen', 'mouthClose', 'mouthSmile', 'mouthFunnel',
            'mouthPucker', 'mouthFrown', 'tongueOut',
            // ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢å½¢å¼
            'Jaw_Open', 'Mouth_Close', 'Mouth_Smile', 'Mouth_Funnel',
            'Mouth_Pucker', 'Mouth_Frown', 'Tongue_Out',
            // Character Creatorå°‚ç”¨Visemeï¼ˆæ–°è¦è¿½åŠ ï¼‰
            'V_Open', 'V_Wide', 'V_Tight_O', 'V_Tight',
            'V_Explosive', 'V_Dental_Lip', 'V_Affricate', 'V_Lip_Open'
        ];

        // Viseme â†’ CC4ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—å¯¾å¿œè¡¨ï¼ˆCharacter Creatorå°‚ç”¨Visemeå„ªå…ˆï¼‰
        // æ³¨: é…åˆ—ã§è¤‡æ•°ã®ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ã‚’æŒ‡å®šå¯èƒ½
        const visemeMapping = {
            // === æ—¥æœ¬èª5æ¯éŸ³ ===
            'a': ['V_Open', 'JawOpen'],  // ã‚ï¼šå£ã‚’å¤§ããé–‹ã + é¡ã‚’é–‹ãï¼ˆçµ„ã¿åˆã‚ã›ï¼‰
            'i': 'V_Wide',               // ã„ï¼šæ¨ªã«åºƒã’ã‚‹
            'u': 'V_Tight_O',            // ã†ï¼šä¸¸ãã™ã¼ã‚ã‚‹
            'e': 'V_Open',               // ãˆï¼šå°‘ã—é–‹ãï¼ˆå¼·åº¦ã§èª¿æ•´ï¼‰
            'o': 'V_Tight_O',            // ãŠï¼šä¸¸ãã™ã¼ã‚ã‚‹ï¼ˆå¼·åº¦ã§èª¿æ•´ï¼‰

            // === å­éŸ³ ===
            'silence': 'MouthClose',  // ç„¡éŸ³ï¼šå£ã‚’é–‰ã˜ã‚‹
            'n': 'MouthClose',        // ã‚“ï¼šå£ã‚’é–‰ã˜ã‚‹
            'k': 'MouthClose',        // ã‹è¡Œï¼šå£ã‚’é–‰ã˜ã‚‹
            's': 'MouthClose',        // ã•è¡Œï¼šå£ã‚’é–‰ã˜ã‚‹
            't': 'MouthClose',        // ãŸè¡Œï¼šå£ã‚’é–‰ã˜ã‚‹
            'm': 'V_Explosive',       // ã¾è¡Œï¼šç ´è£‚éŸ³
            'h': 'V_Lip_Open',        // ã¯è¡Œï¼šå”‡ã‚’é–‹ã
            'y': 'V_Wide',            // ã‚„è¡Œï¼šã€Œã„ã€ã«è¿‘ã„
            'r': 'TongueOut',         // ã‚‰è¡Œï¼šèˆŒã‚’å‡ºã™
            'w': 'V_Tight_O'          // ã‚è¡Œï¼šä¸¸ã‚ã‚‹
        };

        // Visemeã”ã¨ã®æœ€é©å¼·åº¦ï¼ˆæ¨æ¸¬å€¤ï¼‰
        // æ³¨: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§å€‹åˆ¥å¼·åº¦æŒ‡å®šå¯èƒ½ã€æ•°å€¤ã§å…¨ä½“å¼·åº¦æŒ‡å®š
        const visemeStrength = {
            // === æ—¥æœ¬èª5æ¯éŸ³ ===
            'a': { 'V_Open': 0.6, 'JawOpen': 0.7 },  // çµ„ã¿åˆã‚ã›ã§å¤§ããé–‹ã
            'i': 0.5,    // V_Wide - æ¨ªã«åºƒã’ã‚‹
            'u': 0.6,    // V_Tight_O - ã™ã¼ã‚ã‚‹
            'e': 0.35,   // V_Open - å°‘ã—é–‹ãï¼ˆaã‚ˆã‚Šå¼±ã‚ï¼‰
            'o': 0.65,   // V_Tight_O - ã‚„ã‚„å¼·ã‚ã«ã™ã¼ã‚ã‚‹ï¼ˆuã‚ˆã‚Šä¸¸ãï¼‰

            // === å­éŸ³ ===
            'silence': 0.13,  // MouthClose
            'n': 0.13,        // MouthClose
            'k': 0.13,        // MouthClose
            's': 0.13,        // MouthClose
            't': 0.13,        // MouthClose
            'm': 0.5,         // V_Explosive
            'h': 0.4,         // V_Lip_Open
            'y': 0.5,         // V_Wide
            'r': 0.6,         // TongueOut
            'w': 0.6          // V_Tight_O
        };

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®å¤‰æ•°
        let currentVisemeAnimation = null;

        // ========== GLBãƒ­ãƒ¼ãƒ€ãƒ¼ ==========
        const loader = new GLTFLoader();

        // ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚€é–¢æ•°
        function loadGLB(url, filename = 'model.glb') {
            const loading = document.getElementById('loading');
            const loadingText = document.getElementById('loadingText');
            const fileInfo = document.getElementById('fileInfo');

            loading.classList.remove('hidden');
            loadingText.textContent = 'ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...';
            fileInfo.textContent = `${filename} ã‚’èª­ã¿è¾¼ã¿ä¸­...`;
            fileInfo.className = 'info-text';

            // æ—¢å­˜ã®ãƒ¢ãƒ‡ãƒ«ã‚’å‰Šé™¤
            if (currentModel) {
                scene.remove(currentModel);
                currentModel.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            }

            loader.load(
                url,
                (gltf) => {
                    currentGltf = gltf;
                    currentModel = gltf.scene;
                    scene.add(currentModel);

                    // ãƒ¢ãƒ‡ãƒ«ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
                    calculateBoundingBox();

                    // ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’è‡ªå‹•èª¿æ•´
                    adjustCameraToModel();

                    // ãƒ¢ãƒ‡ãƒ«æƒ…å ±ã‚’æ›´æ–°
                    updateModelInfo(gltf);

                    // ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ã‚’æ¤œå‡º
                    detectMorphTargets();

                    loading.classList.add('hidden');
                    fileInfo.textContent = `âœ“ ${filename} ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`;
                    fileInfo.className = 'info-text success';

                    console.log('GLB loaded:', gltf);
                },
                (progress) => {
                    const percent = (progress.loaded / progress.total * 100).toFixed(0);
                    loadingText.textContent = `èª­ã¿è¾¼ã¿ä¸­... ${percent}%`;
                },
                (error) => {
                    console.error('GLB load error:', error);
                    loading.classList.add('hidden');
                    fileInfo.textContent = `âœ— ã‚¨ãƒ©ãƒ¼: ${error.message}`;
                    fileInfo.className = 'info-text error';
                }
            );
        }

        // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
        function calculateBoundingBox() {
            if (!currentModel) return;

            modelBoundingBox = new THREE.Box3().setFromObject(currentModel);
            modelBoundingBox.getCenter(modelCenter);
            modelBoundingBox.getSize(modelSize);

            console.log('Model center:', modelCenter);
            console.log('Model size:', modelSize);

            // ãƒ¢ãƒ‡ãƒ«ã‚’åœ°é¢ï¼ˆY=0ï¼‰ã«é…ç½®
            const yOffset = modelBoundingBox.min.y;
            currentModel.position.y = -yOffset;

            // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’å†è¨ˆç®—
            modelBoundingBox.setFromObject(currentModel);
            modelBoundingBox.getCenter(modelCenter);
            modelBoundingBox.getSize(modelSize);
        }

        // ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’è‡ªå‹•èª¿æ•´ï¼ˆå…¨èº«ãŒè¦‹ãˆã‚‹ã‚ˆã†ã«ï¼‰
        function adjustCameraToModel() {
            if (!modelBoundingBox) return;

            // ãƒ¢ãƒ‡ãƒ«ã®æœ€å¤§ã‚µã‚¤ã‚ºã‚’å–å¾—
            const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z);

            // ã‚«ãƒ¡ãƒ©è·é›¢ã‚’è¨ˆç®—ï¼ˆå…¨èº«ãŒåã¾ã‚‹è·é›¢ï¼‰
            const fov = camera.fov * (Math.PI / 180);
            const cameraDistance = maxDim / (2 * Math.tan(fov / 2)) * 1.5;

            // ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’è¨­å®šï¼ˆæ­£é¢ã‚„ã‚„ä¸Šã‹ã‚‰ï¼‰
            const cameraHeight = modelCenter.y + modelSize.y * 0.2;
            defaultCameraPosition.set(0, cameraHeight, cameraDistance);
            defaultCameraTarget.copy(modelCenter);

            // ã‚«ãƒ¡ãƒ©ã¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’æ›´æ–°
            camera.position.copy(defaultCameraPosition);
            controls.target.copy(defaultCameraTarget);
            controls.update();

            console.log('Camera adjusted - Distance:', cameraDistance, 'Height:', cameraHeight);
        }

        // ãƒ¢ãƒ‡ãƒ«æƒ…å ±ã‚’æ›´æ–°
        function updateModelInfo(gltf) {
            let vertices = 0;
            let faces = 0;
            let meshes = 0;
            const materials = new Set();
            const textures = new Set();

            gltf.scene.traverse((child) => {
                if (child.isMesh) {
                    meshes++;
                    if (child.geometry) {
                        const positions = child.geometry.attributes.position;
                        if (positions) vertices += positions.count;

                        const index = child.geometry.index;
                        if (index) {
                            faces += index.count / 3;
                        } else if (positions) {
                            faces += positions.count / 3;
                        }
                    }

                    if (child.material) {
                        const mats = Array.isArray(child.material) ? child.material : [child.material];
                        mats.forEach(mat => {
                            materials.add(mat.uuid);

                            // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’åé›†
                            if (mat.map) textures.add(mat.map.uuid);
                            if (mat.normalMap) textures.add(mat.normalMap.uuid);
                            if (mat.roughnessMap) textures.add(mat.roughnessMap.uuid);
                            if (mat.metalnessMap) textures.add(mat.metalnessMap.uuid);
                            if (mat.emissiveMap) textures.add(mat.emissiveMap.uuid);
                            if (mat.aoMap) textures.add(mat.aoMap.uuid);
                        });
                    }
                }
            });

            document.getElementById('verticesCount').textContent = vertices.toLocaleString();
            document.getElementById('facesCount').textContent = Math.floor(faces).toLocaleString();
            document.getElementById('meshesCount').textContent = meshes;
            document.getElementById('materialsCount').textContent = materials.size;
            document.getElementById('texturesCount').textContent = textures.size;
        }

        // ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ï¼ˆMorph Targetsï¼‰ã‚’æ¤œå‡º
        function detectMorphTargets() {
            morphTargetMeshes = [];
            const morphTargetsContainer = document.getElementById('morphTargets');
            const morphSection = document.getElementById('morphSection');
            morphTargetsContainer.innerHTML = '';

            if (!currentModel) return;

            let totalMorphTargets = 0;

            currentModel.traverse((child) => {
                if (child.isMesh && child.morphTargetDictionary && child.morphTargetInfluences) {
                    morphTargetMeshes.push(child);

                    const morphNames = Object.keys(child.morphTargetDictionary);
                    totalMorphTargets += morphNames.length;

                    morphNames.forEach((morphName, index) => {
                        const morphItem = document.createElement('div');
                        morphItem.className = 'morph-item';

                        const morphNameLabel = document.createElement('div');
                        morphNameLabel.className = 'morph-name';
                        morphNameLabel.textContent = morphName;

                        const sliderContainer = document.createElement('div');
                        sliderContainer.className = 'slider-label';

                        const sliderLabel = document.createElement('span');
                        sliderLabel.textContent = 'å¼·åº¦';

                        const sliderValue = document.createElement('span');
                        sliderValue.className = 'slider-value';
                        sliderValue.textContent = '0.0';

                        sliderContainer.appendChild(sliderLabel);
                        sliderContainer.appendChild(sliderValue);

                        const slider = document.createElement('input');
                        slider.type = 'range';
                        slider.min = '0';
                        slider.max = '1';
                        slider.step = '0.01';
                        slider.value = '0';
                        slider.addEventListener('input', (e) => {
                            const value = parseFloat(e.target.value);
                            sliderValue.textContent = value.toFixed(2);
                            child.morphTargetInfluences[index] = value;
                        });

                        morphItem.appendChild(morphNameLabel);
                        morphItem.appendChild(sliderContainer);
                        morphItem.appendChild(slider);
                        morphTargetsContainer.appendChild(morphItem);
                    });
                }
            });

            document.getElementById('morphTargetsCount').textContent = totalMorphTargets;

            if (totalMorphTargets > 0) {
                morphSection.style.display = 'block';
            } else {
                morphSection.style.display = 'none';
            }

            console.log('Detected morph targets:', totalMorphTargets);

            // ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ä¸€è¦§ã‚’ç”Ÿæˆ
            generateBlendShapeList();

            // Visemeãƒ†ã‚¹ãƒˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤º
            if (totalMorphTargets > 0) {
                document.getElementById('visemeTestSection').style.display = 'block';
            } else {
                document.getElementById('visemeTestSection').style.display = 'none';
            }
        }

        // ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ä¸€è¦§ã‚’ç”Ÿæˆ
        function generateBlendShapeList() {
            blendShapeData = [];
            const blendshapeListSection = document.getElementById('blendshapeListSection');

            if (!currentModel) return;

            // ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’åé›†
            currentModel.traverse((child) => {
                if (child.isMesh && child.morphTargetDictionary && child.morphTargetInfluences) {
                    const meshName = child.name || 'Unnamed Mesh';
                    const morphNames = Object.keys(child.morphTargetDictionary);

                    morphNames.forEach((morphName) => {
                        const index = child.morphTargetDictionary[morphName];
                        const isLipSync = isLipSyncBlendShape(morphName);

                        blendShapeData.push({
                            meshName: meshName,
                            name: morphName,
                            index: index,
                            isLipSync: isLipSync,
                            mesh: child
                        });
                    });
                }
            });

            if (blendShapeData.length > 0) {
                blendshapeListSection.style.display = 'block';
                displayBlendShapeList();
            } else {
                blendshapeListSection.style.display = 'none';
            }

            console.log('BlendShape data collected:', blendShapeData.length);
        }

        // ãƒªãƒƒãƒ—ã‚·ãƒ³ã‚¯ç”¨ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ã‹ã©ã†ã‹ã‚’åˆ¤å®š
        function isLipSyncBlendShape(name) {
            return lipSyncBlendShapes.some(lsName =>
                name.toLowerCase().includes(lsName.toLowerCase()) ||
                lsName.toLowerCase().includes(name.toLowerCase())
            );
        }

        // ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ä¸€è¦§ã‚’è¡¨ç¤º
        function displayBlendShapeList(filterText = '', lipSyncOnly = false) {
            const container = document.getElementById('blendshapeListContainer');
            container.innerHTML = '';

            // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å‡¦ç†
            let filteredData = blendShapeData;

            if (filterText) {
                filteredData = filteredData.filter(bs =>
                    bs.name.toLowerCase().includes(filterText.toLowerCase())
                );
            }

            if (lipSyncOnly) {
                filteredData = filteredData.filter(bs => bs.isLipSync);
            }

            if (filteredData.length === 0) {
                container.innerHTML = '<div class="no-results">è©²å½“ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ãŒã‚ã‚Šã¾ã›ã‚“</div>';
                return;
            }

            // ãƒ¡ãƒƒã‚·ãƒ¥ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
            const groupedByMesh = filteredData.reduce((acc, bs) => {
                if (!acc[bs.meshName]) {
                    acc[bs.meshName] = [];
                }
                acc[bs.meshName].push(bs);
                return acc;
            }, {});

            // ãƒ¡ãƒƒã‚·ãƒ¥ã”ã¨ã«è¡¨ç¤º
            Object.keys(groupedByMesh).forEach(meshName => {
                const meshGroup = document.createElement('div');
                meshGroup.className = 'mesh-group';

                // ãƒ¡ãƒƒã‚·ãƒ¥ãƒ˜ãƒƒãƒ€ãƒ¼
                const meshHeader = document.createElement('div');
                meshHeader.className = 'mesh-header';
                meshHeader.innerHTML = `
                    <span>ğŸ“ ${meshName} (${groupedByMesh[meshName].length})</span>
                    <span class="toggle-icon">â–¼</span>
                `;

                // æŠ˜ã‚ŠãŸãŸã¿æ©Ÿèƒ½
                const blendShapeContainer = document.createElement('div');
                blendShapeContainer.className = 'blendshape-container';

                meshHeader.addEventListener('click', () => {
                    meshHeader.classList.toggle('collapsed');
                    blendShapeContainer.style.display =
                        meshHeader.classList.contains('collapsed') ? 'none' : 'block';
                });

                // ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ã‚¢ã‚¤ãƒ†ãƒ ã‚’ä½œæˆ
                groupedByMesh[meshName].forEach(bs => {
                    const item = document.createElement('div');
                    item.className = 'blendshape-item';
                    if (bs.isLipSync) {
                        item.classList.add('lip-sync');
                    }
                    if (filterText && bs.name.toLowerCase().includes(filterText.toLowerCase())) {
                        item.classList.add('highlight');
                    }

                    item.innerHTML = `
                        <span class="blendshape-index">[${bs.index}]</span>
                        <span class="blendshape-name">${bs.name}</span>
                        ${bs.isLipSync ? '<span class="badge lip-sync">ğŸ¤ ãƒªãƒƒãƒ—ã‚·ãƒ³ã‚¯</span>' : ''}
                    `;

                    blendShapeContainer.appendChild(item);
                });

                meshGroup.appendChild(meshHeader);
                meshGroup.appendChild(blendShapeContainer);
                container.appendChild(meshGroup);
            });
        }

        // ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ã‚’ãƒªã‚»ãƒƒãƒˆ
        window.resetMorphTargets = function() {
            morphTargetMeshes.forEach(mesh => {
                if (mesh.morphTargetInfluences) {
                    mesh.morphTargetInfluences.fill(0);
                }
            });

            // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚‚ãƒªã‚»ãƒƒãƒˆ
            const sliders = document.querySelectorAll('#morphTargets input[type="range"]');
            const values = document.querySelectorAll('#morphTargets .slider-value');
            sliders.forEach(slider => slider.value = 0);
            values.forEach(value => value.textContent = '0.0');

            console.log('Morph targets reset');
        };

        // ========== Visemeæ©Ÿèƒ½ ==========

        // ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—åã‚’æ¤œç´¢ï¼ˆCC4å½¢å¼ã«å¯¾å¿œ + é‡è¤‡é™¤å¤–ï¼‰
        function findBlendShapeNames(baseName) {
            const foundNames = [];
            const uniqueMeshes = new Set();

            // åå‰ã®ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆ
            const variations = [
                baseName,                           // MouthSmile
                baseName.replace(/([A-Z])/g, '_$1').substring(1), // Mouth_Smile
                baseName + '_L',                    // MouthSmile_L
                baseName + '_R',                    // MouthSmile_R
                baseName.replace(/([A-Z])/g, '_$1').substring(1) + '_L', // Mouth_Smile_L
                baseName.replace(/([A-Z])/g, '_$1').substring(1) + '_R', // Mouth_Smile_R
                baseName + '_Up_L',
                baseName + '_Up_R',
                baseName + '_Down_L',
                baseName + '_Down_R',
                baseName.replace(/([A-Z])/g, '_$1').substring(1) + '_Up_L',
                baseName.replace(/([A-Z])/g, '_$1').substring(1) + '_Up_R',
                baseName.replace(/([A-Z])/g, '_$1').substring(1) + '_Down_L',
                baseName.replace(/([A-Z])/g, '_$1').substring(1) + '_Down_R'
            ];

            // å„ãƒ¡ãƒƒã‚·ãƒ¥ã‹ã‚‰1ã¤ã ã‘å–å¾—ï¼ˆé‡è¤‡é™¤å¤–ï¼‰
            morphTargetMeshes.forEach(mesh => {
                // ã“ã®ãƒ¡ãƒƒã‚·ãƒ¥ã¯æ—¢ã«å‡¦ç†æ¸ˆã¿
                if (uniqueMeshes.has(mesh.uuid)) return;

                if (mesh.morphTargetDictionary) {
                    // ã“ã®ãƒ¡ãƒƒã‚·ãƒ¥ã‹ã‚‰ãƒãƒƒãƒã™ã‚‹æœ€åˆã®ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ã‚’è¦‹ã¤ã‘ã‚‹
                    for (const morphName of Object.keys(mesh.morphTargetDictionary)) {
                        let matched = false;

                        for (const variant of variations) {
                            if (morphName === variant || morphName.toLowerCase() === variant.toLowerCase()) {
                                foundNames.push({
                                    mesh: mesh,
                                    name: morphName,
                                    index: mesh.morphTargetDictionary[morphName]
                                });
                                uniqueMeshes.add(mesh.uuid);
                                matched = true;
                                break;
                            }
                        }

                        if (matched) break; // ã“ã®ãƒ¡ãƒƒã‚·ãƒ¥ã‹ã‚‰ã¯1ã¤ã ã‘
                    }
                }
            });

            return foundNames;
        }

        // Visemeã‚’é©ç”¨ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãï¼‰
        window.applyViseme = function(visemeName) {
            // ç¾åœ¨ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            if (currentVisemeAnimation) {
                cancelAnimationFrame(currentVisemeAnimation);
                currentVisemeAnimation = null;
            }

            // Visemeã«å¯¾å¿œã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—åã‚’å–å¾—ï¼ˆé…åˆ—å¯¾å¿œï¼‰
            let blendShapeNames = visemeMapping[visemeName];
            if (!blendShapeNames) {
                console.warn(`Unknown viseme: ${visemeName}`);
                return;
            }

            // æ–‡å­—åˆ—ã®å ´åˆã¯é…åˆ—ã«å¤‰æ›
            if (!Array.isArray(blendShapeNames)) {
                blendShapeNames = [blendShapeNames];
            }

            // å…¨ã¦ã®ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ã‚’æ¤œç´¢
            const allBlendShapes = [];
            blendShapeNames.forEach(blendShapeName => {
                const found = findBlendShapeNames(blendShapeName);
                if (found.length > 0) {
                    // ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—åã‚’å„è¦ç´ ã«è¿½åŠ ï¼ˆå¼·åº¦ãƒãƒƒãƒ”ãƒ³ã‚°ç”¨ï¼‰
                    found.forEach(bs => {
                        bs.blendShapeType = blendShapeName;
                    });
                    allBlendShapes.push(...found);
                } else {
                    console.warn(`BlendShape not found for: ${blendShapeName}`);
                }
            });

            if (allBlendShapes.length === 0) {
                console.warn(`No blend shapes found for viseme: ${visemeName}`);
                return;
            }

            // Visemeã”ã¨ã®æœ€é©å¼·åº¦ã‚’å–å¾—
            const strengthConfig = visemeStrength[visemeName] || 1.0;

            console.log(`Applying viseme '${visemeName}' -> [${blendShapeNames.join(', ')}]`);
            console.log(`Found ${allBlendShapes.length} blend shapes:`, allBlendShapes.map(bs => bs.name));
            console.log(`Strength config:`, strengthConfig);

            // ã™ã¹ã¦ã®ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ã‚’ãƒªã‚»ãƒƒãƒˆ
            window.resetMorphTargets();

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆ0 â†’ maxStrength â†’ 0ï¼‰
            const duration = 1000; // 1ç§’
            const startTime = performance.now();

            function animate() {
                const elapsed = performance.now() - startTime;
                const progress = elapsed / duration;

                if (progress >= 1) {
                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†
                    allBlendShapes.forEach(bs => {
                        bs.mesh.morphTargetInfluences[bs.index] = 0;
                    });
                    currentVisemeAnimation = null;
                    return;
                }

                // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆ0â†’1â†’0ã®ä¸‰è§’æ³¢ï¼‰
                let progressValue;
                if (progress < 0.5) {
                    // 0 â†’ 1 (å‰åŠ)
                    progressValue = progress * 2;
                } else {
                    // 1 â†’ 0 (å¾ŒåŠ)
                    progressValue = (1 - progress) * 2;
                }

                // å…¨ã¦ã®ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ã«å€¤ã‚’é©ç”¨
                allBlendShapes.forEach(bs => {
                    // å¼·åº¦ã‚’å–å¾—ï¼ˆå€‹åˆ¥è¨­å®šã¾ãŸã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
                    let strength;
                    if (typeof strengthConfig === 'object') {
                        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ã‚¿ã‚¤ãƒ—ã”ã¨ã®å¼·åº¦ã‚’å–å¾—
                        strength = strengthConfig[bs.blendShapeType] || 1.0;
                    } else {
                        // æ•°å€¤ã®å ´åˆã€å…¨ä½“ã«é©ç”¨
                        strength = strengthConfig;
                    }

                    const value = progressValue * strength;
                    bs.mesh.morphTargetInfluences[bs.index] = value;
                });

                currentVisemeAnimation = requestAnimationFrame(animate);
            }

            animate();

            // ãƒœã‚¿ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’è¡¨ç¤ºï¼ˆä¸€æ™‚çš„ï¼‰
            const buttons = document.querySelectorAll('.viseme-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            event?.target?.closest('.viseme-btn')?.classList.add('active');
            setTimeout(() => {
                event?.target?.closest('.viseme-btn')?.classList.remove('active');
            }, 300);
        };

        // Visemeãƒªã‚»ãƒƒãƒˆ
        window.resetViseme = function() {
            if (currentVisemeAnimation) {
                cancelAnimationFrame(currentVisemeAnimation);
                currentVisemeAnimation = null;
            }
            window.resetMorphTargets();
            console.log('Viseme reset');
        };

        // ã‚«ãƒ¡ãƒ©ãƒ—ãƒªã‚»ãƒƒãƒˆ
        window.setCameraPreset = function(preset) {
            if (!modelBoundingBox) return;

            const distance = defaultCameraPosition.length();
            let targetPos = new THREE.Vector3();
            let targetLookAt = modelCenter.clone();

            switch(preset) {
                case 'front':
                    targetPos.set(0, modelCenter.y, distance);
                    break;
                case 'back':
                    targetPos.set(0, modelCenter.y, -distance);
                    break;
                case 'left':
                    targetPos.set(-distance, modelCenter.y, 0);
                    break;
                case 'right':
                    targetPos.set(distance, modelCenter.y, 0);
                    break;
                case 'top':
                    targetPos.set(0, distance * 1.5, 0);
                    break;
                case 'reset':
                    targetPos.copy(defaultCameraPosition);
                    targetLookAt.copy(defaultCameraTarget);
                    break;
            }

            // ã‚¹ãƒ ãƒ¼ã‚ºãªã‚«ãƒ¡ãƒ©ç§»å‹•
            animateCamera(targetPos, targetLookAt);
        };

        // ã‚«ãƒ¡ãƒ©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
        function animateCamera(targetPosition, targetLookAt, duration = 1000) {
            const startPosition = camera.position.clone();
            const startLookAt = controls.target.clone();
            const startTime = performance.now();

            function animate() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆease-in-outï¼‰
                const eased = progress < 0.5
                    ? 4 * progress * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;

                camera.position.lerpVectors(startPosition, targetPosition, eased);
                controls.target.lerpVectors(startLookAt, targetLookAt, eased);
                controls.update();

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }

            animate();
        }

        // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
        window.takeScreenshot = function() {
            renderer.render(scene, camera);
            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `screenshot_${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
            console.log('Screenshot taken');
        };

        // ========== ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½ ==========

        // JSONå½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
        window.exportBlendShapesJSON = function() {
            if (blendShapeData.length === 0) {
                alert('ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                return;
            }

            // ãƒ¡ãƒƒã‚·ãƒ¥ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
            const groupedByMesh = blendShapeData.reduce((acc, bs) => {
                if (!acc[bs.meshName]) {
                    acc[bs.meshName] = [];
                }
                acc[bs.meshName].push({
                    index: bs.index,
                    name: bs.name,
                    isLipSync: bs.isLipSync
                });
                return acc;
            }, {});

            const exportData = {
                modelName: currentGltf ? (currentGltf.asset?.generator || 'Unknown') : 'Unknown',
                totalBlendShapes: blendShapeData.length,
                lipSyncBlendShapes: blendShapeData.filter(bs => bs.isLipSync).length,
                meshes: Object.keys(groupedByMesh).map(meshName => ({
                    meshName: meshName,
                    blendShapeCount: groupedByMesh[meshName].length,
                    blendShapes: groupedByMesh[meshName]
                }))
            };

            const jsonString = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `blendshapes_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            console.log('Exported BlendShapes as JSON');
        };

        // ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
        window.exportBlendShapesText = function() {
            if (blendShapeData.length === 0) {
                alert('ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                return;
            }

            let textContent = `ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ä¸€è¦§\n`;
            textContent += `ç·æ•°: ${blendShapeData.length}\n`;
            textContent += `ãƒªãƒƒãƒ—ã‚·ãƒ³ã‚¯ç”¨: ${blendShapeData.filter(bs => bs.isLipSync).length}\n`;
            textContent += `\n${'='.repeat(60)}\n\n`;

            // ãƒ¡ãƒƒã‚·ãƒ¥ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
            const groupedByMesh = blendShapeData.reduce((acc, bs) => {
                if (!acc[bs.meshName]) {
                    acc[bs.meshName] = [];
                }
                acc[bs.meshName].push(bs);
                return acc;
            }, {});

            Object.keys(groupedByMesh).forEach(meshName => {
                textContent += `ğŸ“ ${meshName} (${groupedByMesh[meshName].length}å€‹)\n`;
                textContent += `${'-'.repeat(60)}\n`;

                groupedByMesh[meshName].forEach(bs => {
                    const lipSyncMarker = bs.isLipSync ? ' [ğŸ¤ ãƒªãƒƒãƒ—ã‚·ãƒ³ã‚¯]' : '';
                    textContent += `  [${bs.index}] ${bs.name}${lipSyncMarker}\n`;
                });

                textContent += `\n`;
            });

            const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `blendshapes_${Date.now()}.txt`;
            a.click();
            URL.revokeObjectURL(url);

            console.log('Exported BlendShapes as Text');
        };

        // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
        window.copyBlendShapesToClipboard = async function() {
            if (blendShapeData.length === 0) {
                alert('ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                return;
            }

            let textContent = `ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ä¸€è¦§ (ç·æ•°: ${blendShapeData.length})\n\n`;

            // ãƒ¡ãƒƒã‚·ãƒ¥ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
            const groupedByMesh = blendShapeData.reduce((acc, bs) => {
                if (!acc[bs.meshName]) {
                    acc[bs.meshName] = [];
                }
                acc[bs.meshName].push(bs);
                return acc;
            }, {});

            Object.keys(groupedByMesh).forEach(meshName => {
                textContent += `${meshName}:\n`;
                groupedByMesh[meshName].forEach(bs => {
                    const lipSyncMarker = bs.isLipSync ? ' [ãƒªãƒƒãƒ—ã‚·ãƒ³ã‚¯]' : '';
                    textContent += `  - ${bs.name}${lipSyncMarker}\n`;
                });
                textContent += `\n`;
            });

            try {
                await navigator.clipboard.writeText(textContent);
                alert('ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—ä¸€è¦§ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
                console.log('Copied BlendShapes to clipboard');
            } catch (err) {
                console.error('Failed to copy to clipboard:', err);
                alert('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã¸ã®ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        };

        // ========== UIã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« ==========

        // Google Driveã®URLã‚’ç›´æ¥ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å¯èƒ½ãªå½¢å¼ã«å¤‰æ›
        function convertGoogleDriveURL(url) {
            // Google Driveã®ãƒ•ã‚¡ã‚¤ãƒ«IDã‚’æŠ½å‡º
            const match = url.match(/\/d\/([a-zA-Z0-9_-]+)/);
            if (match && match[1]) {
                const fileId = match[1];
                // ç›´æ¥ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å¯èƒ½ãªURLã«å¤‰æ›
                return `https://drive.google.com/uc?export=download&id=${fileId}`;
            }
            return url;
        }

        // URLã‹ã‚‰èª­ã¿è¾¼ã¿
        window.loadFromURL = function() {
            const urlInput = document.getElementById('urlInput');
            let url = urlInput.value.trim();

            if (!url) {
                alert('URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }

            // Google Driveã®URLã®å ´åˆã¯å¤‰æ›
            if (url.includes('drive.google.com')) {
                url = convertGoogleDriveURL(url);
            }

            // URLã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å–å¾—
            const filename = url.split('/').pop()?.split('?')[0] || 'model.glb';
            loadGLB(url, filename);
        };

        // Enterã‚­ãƒ¼ã§ã‚‚èª­ã¿è¾¼ã¿
        document.getElementById('urlInput').addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                window.loadFromURL();
            }
        });

        // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ
        document.getElementById('fileInput').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                loadGLB(url, file.name);
            }
        });

        // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—
        canvas.addEventListener('dragover', (event) => {
            event.preventDefault();
        });

        canvas.addEventListener('drop', (event) => {
            event.preventDefault();
            const file = event.dataTransfer.files[0];
            if (file && (file.name.endsWith('.glb') || file.name.endsWith('.gltf'))) {
                const url = URL.createObjectURL(file);
                loadGLB(url, file.name);
            }
        });

        // ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
        document.getElementById('gridToggle').addEventListener('change', (event) => {
            gridHelper.visible = event.target.checked;
        });

        // è‡ªå‹•å›è»¢
        document.getElementById('autoRotate').addEventListener('change', (event) => {
            autoRotateEnabled = event.target.checked;
        });

        // èƒŒæ™¯è‰²
        document.getElementById('bgColorPicker').addEventListener('input', (event) => {
            scene.background = new THREE.Color(event.target.value);
        });

        // å¤ªé™½å…‰ã®å¼·åº¦
        document.getElementById('directionalLightSlider').addEventListener('input', (event) => {
            const value = parseFloat(event.target.value);
            directionalLight.intensity = value * Math.PI;
            document.getElementById('directionalLightValue').textContent = value.toFixed(1);
        });

        // ç’°å¢ƒå…‰ã®å¼·åº¦
        document.getElementById('ambientLightSlider').addEventListener('input', (event) => {
            const value = parseFloat(event.target.value);
            ambientLight.intensity = value * Math.PI;
            document.getElementById('ambientLightValue').textContent = value.toFixed(1);
        });

        // ========== ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚·ã‚§ã‚¤ãƒ—æ¤œç´¢ãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ ==========

        // æ¤œç´¢æ©Ÿèƒ½
        document.getElementById('blendshapeSearch').addEventListener('input', (event) => {
            const searchText = event.target.value;
            const lipSyncOnly = document.getElementById('lipSyncFilter').checked;
            displayBlendShapeList(searchText, lipSyncOnly);
        });

        // ãƒªãƒƒãƒ—ã‚·ãƒ³ã‚¯ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
        document.getElementById('lipSyncFilter').addEventListener('change', (event) => {
            const searchText = document.getElementById('blendshapeSearch').value;
            const lipSyncOnly = event.target.checked;
            displayBlendShapeList(searchText, lipSyncOnly);
        });

        // ========== ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚º ==========
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ========== ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ— ==========
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            // è‡ªå‹•å›è»¢
            if (autoRotateEnabled && currentModel) {
                currentModel.rotation.y += deltaTime * 0.5;
            }

            // OrbitControlsã®æ›´æ–° 
            controls.update();

            renderer.render(scene, camera);
        }

        animate();

        // ========== åˆæœŸèª­ã¿è¾¼ã¿ ==========
        // èµ·å‹•æ™‚ã«Google Driveã‹ã‚‰GLBãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
        const downloadURL = 'https://3d-models-rho.vercel.app/asset/model.glb';

        // URLã‚’å…¥åŠ›æ¬„ã«è¡¨ç¤º
        document.getElementById('urlInput').value = downloadURL;

        // ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã¿
        loadGLB(downloadURL, 'model.glb');

    </script>
</body>
</html>
